// Autogenerated from Pigeon (v14.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

enum NotificationTriggerType {
  timeInterval,
  dateComponents,
}

class NotificationRequest {
  NotificationRequest({
    required this.identifier,
    required this.content,
    this.trigger,
  });

  String identifier;

  NotificationContent content;

  NotificationTrigger? trigger;

  Object encode() {
    return <Object?>[
      identifier,
      content.encode(),
      trigger?.encode(),
    ];
  }

  static NotificationRequest decode(Object result) {
    result as List<Object?>;
    return NotificationRequest(
      identifier: result[0]! as String,
      content: NotificationContent.decode(result[1]! as List<Object?>),
      trigger: result[2] != null
          ? NotificationTrigger.decode(result[2]! as List<Object?>)
          : null,
    );
  }
}

class NotificationContent {
  NotificationContent({
    required this.title,
    required this.body,
  });

  String title;

  String body;

  Object encode() {
    return <Object?>[
      title,
      body,
    ];
  }

  static NotificationContent decode(Object result) {
    result as List<Object?>;
    return NotificationContent(
      title: result[0]! as String,
      body: result[1]! as String,
    );
  }
}

class NotificationDateComponents {
  NotificationDateComponents({
    this.year,
    this.month,
    this.day,
    this.hour,
    this.minute,
    this.second,
    this.weekday,
  });

  int? year;

  int? month;

  int? day;

  int? hour;

  int? minute;

  int? second;

  int? weekday;

  Object encode() {
    return <Object?>[
      year,
      month,
      day,
      hour,
      minute,
      second,
      weekday,
    ];
  }

  static NotificationDateComponents decode(Object result) {
    result as List<Object?>;
    return NotificationDateComponents(
      year: result[0] as int?,
      month: result[1] as int?,
      day: result[2] as int?,
      hour: result[3] as int?,
      minute: result[4] as int?,
      second: result[5] as int?,
      weekday: result[6] as int?,
    );
  }
}

class NotificationTrigger {
  NotificationTrigger({
    required this.repeats,
    this.timeInterval,
    this.dateComponents,
    required this.type,
  });

  bool repeats;

  int? timeInterval;

  NotificationDateComponents? dateComponents;

  NotificationTriggerType type;

  Object encode() {
    return <Object?>[
      repeats,
      timeInterval,
      dateComponents?.encode(),
      type.index,
    ];
  }

  static NotificationTrigger decode(Object result) {
    result as List<Object?>;
    return NotificationTrigger(
      repeats: result[0]! as bool,
      timeInterval: result[1] as int?,
      dateComponents: result[2] != null
          ? NotificationDateComponents.decode(result[2]! as List<Object?>)
          : null,
      type: NotificationTriggerType.values[result[3]! as int],
    );
  }
}

class _LocalNotificationWithAppleCodec extends StandardMessageCodec {
  const _LocalNotificationWithAppleCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is NotificationContent) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is NotificationDateComponents) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is NotificationRequest) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is NotificationRequest) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is NotificationTrigger) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return NotificationContent.decode(readValue(buffer)!);
      case 129: 
        return NotificationDateComponents.decode(readValue(buffer)!);
      case 130: 
        return NotificationRequest.decode(readValue(buffer)!);
      case 131: 
        return NotificationRequest.decode(readValue(buffer)!);
      case 132: 
        return NotificationTrigger.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class LocalNotificationWithApple {
  /// Constructor for [LocalNotificationWithApple].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  LocalNotificationWithApple({BinaryMessenger? binaryMessenger})
      : __pigeon_binaryMessenger = binaryMessenger;
  final BinaryMessenger? __pigeon_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _LocalNotificationWithAppleCodec();

  /// 添加通知请求
  Future<void> add(NotificationRequest request) async {
    const String __pigeon_channelName = 'dev.flutter.pigeon.local_notification_with_apple.LocalNotificationWithApple.add';
    final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[request]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  /// 移除指定pengding状态的通知
  Future<void> removePendingNotificationRequests(List<String?> identifiers) async {
    const String __pigeon_channelName = 'dev.flutter.pigeon.local_notification_with_apple.LocalNotificationWithApple.removePendingNotificationRequests';
    final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(<Object?>[identifiers]) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  /// 移除pengding状态的通知
  Future<void> removeAllPendingNotificationRequests() async {
    const String __pigeon_channelName = 'dev.flutter.pigeon.local_notification_with_apple.LocalNotificationWithApple.removeAllPendingNotificationRequests';
    final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else {
      return;
    }
  }

  /// 获取所有pengding状态的通知
  Future<List<NotificationRequest?>> getPendingNotificationRequests() async {
    const String __pigeon_channelName = 'dev.flutter.pigeon.local_notification_with_apple.LocalNotificationWithApple.getPendingNotificationRequests';
    final BasicMessageChannel<Object?> __pigeon_channel = BasicMessageChannel<Object?>(
      __pigeon_channelName,
      pigeonChannelCodec,
      binaryMessenger: __pigeon_binaryMessenger,
    );
    final List<Object?>? __pigeon_replyList =
        await __pigeon_channel.send(null) as List<Object?>?;
    if (__pigeon_replyList == null) {
      throw _createConnectionError(__pigeon_channelName);
    } else if (__pigeon_replyList.length > 1) {
      throw PlatformException(
        code: __pigeon_replyList[0]! as String,
        message: __pigeon_replyList[1] as String?,
        details: __pigeon_replyList[2],
      );
    } else if (__pigeon_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (__pigeon_replyList[0] as List<Object?>?)!.cast<NotificationRequest?>();
    }
  }
}
